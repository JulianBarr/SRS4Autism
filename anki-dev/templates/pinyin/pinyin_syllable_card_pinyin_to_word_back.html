<script src="_pinyin_db.js"></script>

{{FrontSide}}

<hr id="answer">

<div class="answer-section">
  <p><strong>正确答案:</strong> <span class="correct-answer">{{WordHanzi}}</span></p>
  <p><strong>拼音:</strong> {{WordPinyin}}</p>
</div>

<!-- Hidden data elements (safe from JavaScript syntax errors) -->
<div id="data-correct-pic" style="display:none;">{{WordPicture}}</div>
<div id="data-correct-syllable" style="display:none;">{{Syllable}}</div>

<script>
(function() {
  // Read data safely from hidden DOM elements
  const correctPicEl = document.getElementById('data-correct-pic');
  const correctSyllableEl = document.getElementById('data-correct-syllable');
  const container = document.getElementById('mcq-container');
  
  if (!correctPicEl || !correctSyllableEl || !container) return;
  
  const correctPicture = correctPicEl.innerHTML.trim();
  const correctAnswer = correctSyllableEl.innerText.trim();
  
  // Deterministic seeded random generator (same as front)
  let seed = 0;
  const seedString = correctAnswer;
  for (let i = 0; i < seedString.length; i++) {
    seed = (seed + seedString.charCodeAt(i)) % 100000;
  }
  const seededRandom = function() {
    var x = Math.sin(seed++) * 10000;
    return x - Math.floor(x);
  };
  
  // Fisher-Yates shuffle with seeded random
  function shuffleArray(array) {
    const shuffled = array.slice();
    for (let i = shuffled.length - 1; i > 0; i--) {
      const j = Math.floor(seededRandom() * (i + 1));
      [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
    }
    return shuffled;
  }
  
  // Function to select distractor images from PINYIN_DB (same as front)
  function selectDistractorImages(db, correctSyllable, count) {
    // Filter out the correct answer and get entries with pictures
    const available = db
      .filter(item => item.syllable && item.syllable !== correctSyllable && item.pic)
      .map(item => ({ syllable: item.syllable, pic: item.pic }));
    
    // Remove duplicates based on syllable
    const seen = new Set();
    const unique = available.filter(item => {
      if (seen.has(item.syllable)) {
        return false;
      }
      seen.add(item.syllable);
      return true;
    });
    
    // If we don't have enough distractors, return what we have
    if (unique.length < count) {
      return unique;
    }
    
    // Select random distractors using seeded random
    const selected = [];
    const candidates = unique.slice();
    
    for (let i = 0; i < count && candidates.length > 0; i++) {
      const index = Math.floor(seededRandom() * candidates.length);
      selected.push(candidates[index]);
      candidates.splice(index, 1);
    }
    
    return selected;
  }
  
  // Fallback: Render just the correct answer centered
  function renderFallback() {
    container.innerHTML = '';
    const div = document.createElement('div');
    div.className = 'mcq-picture-option selected';
    div.setAttribute('data-correct', 'true');
    div.setAttribute('data-value', correctAnswer);
    div.innerHTML = correctPicture;
    div.style.margin = '0 auto';
    div.style.maxWidth = '300px';
    div.style.pointerEvents = 'none';
    container.appendChild(div);
  }
  
  // Function to ensure options are generated and in correct order
  function ensureOptionsGenerated() {
    // Check if options already exist (from front side)
    const existingOptions = container.querySelectorAll('.mcq-picture-option');
    
    if (existingOptions.length === 0) {
      // Options weren't generated on front side, try to generate them now
      if (typeof window === 'undefined' || !window.PINYIN_DB || !Array.isArray(window.PINYIN_DB)) {
        // DB not available, render fallback
        renderFallback();
        return;
      }
      
      const db = window.PINYIN_DB;
      const distractorImages = selectDistractorImages(db, correctAnswer, 3);
      
      // Create option objects: correct answer + distractors
      const options = [
        { 
          syllable: correctAnswer, 
          pic: correctPicture, 
          isCorrect: true 
        },
        ...distractorImages.map(item => ({
          syllable: item.syllable,
          pic: item.pic,
          isCorrect: false
        }))
      ];
      
      // Create image button elements
      const buttons = options.map(option => {
        const div = document.createElement('div');
        div.className = 'mcq-picture-option';
        div.setAttribute('data-correct', option.isCorrect ? 'true' : 'false');
        div.setAttribute('data-value', option.syllable);
        
        // Insert the picture HTML
        if (option.isCorrect) {
          div.innerHTML = correctPicture;
        } else {
          const img = document.createElement('img');
          img.src = option.pic;
          img.style.maxWidth = '100%';
          img.style.height = 'auto';
          div.appendChild(img);
        }
        
        return div;
      });
      
      container.innerHTML = '';
      const shuffled = shuffleArray(buttons);
      shuffled.forEach(btn => container.appendChild(btn));
    }
    // If options already exist, preserve their order (they were already shuffled by front side)
    
    // Re-query after potential generation
    const finalOptions = container.querySelectorAll('.mcq-picture-option');
    
    // Disable all buttons
    finalOptions.forEach(option => {
      option.style.pointerEvents = 'none';
      option.style.cursor = 'default';
      
      // Remove all event listeners by cloning
      const newOption = option.cloneNode(true);
      option.parentNode.replaceChild(newOption, option);
    });
    
    // Highlight correct answer
    const newOptions = container.querySelectorAll('.mcq-picture-option');
    newOptions.forEach(option => {
      if (option.getAttribute('data-correct') === 'true') {
        option.classList.add('selected');
      }
    });
  }
  
  // Try to ensure options are generated, with fallback after 2 seconds
  let attempts = 0;
  const maxAttempts = 40; // 40 * 50ms = 2 seconds
  
  function tryEnsure() {
    attempts++;
    
    // Check if DB is available
    if (typeof window !== 'undefined' && window.PINYIN_DB && Array.isArray(window.PINYIN_DB)) {
      ensureOptionsGenerated();
      return;
    }
    
    // If we've tried for 2 seconds, render fallback
    if (attempts >= maxAttempts) {
      renderFallback();
      return;
    }
    
    // Retry after a short delay
    setTimeout(tryEnsure, 50);
  }
  
  // Start trying to ensure options are generated
  tryEnsure();
})();
</script>
