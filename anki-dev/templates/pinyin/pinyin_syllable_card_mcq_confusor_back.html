<script src="_pinyin_db.js"></script>

{{FrontSide}}

<hr id="answer">

<div class="answer-section">
  <p><strong>正确答案:</strong> <span class="correct-answer">{{Syllable}}</span></p>
</div>

<!-- Hidden data elements (safe from JavaScript syntax errors) -->
<div id="data-correct-syllable" style="display:none;">{{Syllable}}</div>

<script>
(function() {
  // Read data safely from hidden DOM elements
  const correctSyllableEl = document.getElementById('data-correct-syllable');
  const container = document.getElementById('mcq-container');
  if (!correctSyllableEl || !container) return;
  
  const correctAnswer = correctSyllableEl.innerText.trim();
  
  // Expanded Confusion Groups (same as front)
  const CONFUSION_GROUPS = {
    // Initials
    'b': ['p', 'd', 'q'], 'p': ['b', 'd', 'q'],
    'd': ['b', 'p', 'q', 't'], 'q': ['p', 'b', 'd'],
    'n': ['l', 'm'], 'l': ['n', 'r'],
    'm': ['n', 'f'], 'f': ['h', 'm'],
    'z': ['zh', 'c', 's'], 'c': ['ch', 'z', 's'], 's': ['sh', 'z', 'c'],
    'zh': ['z', 'ch', 'sh', 'r'], 'ch': ['c', 'zh', 'sh'], 'sh': ['s', 'zh', 'ch'],
    'j': ['q', 'x'], 'q': ['j', 'x'], 'x': ['j', 'q', 'sh'],
    'g': ['k', 'h'], 'k': ['g', 'h'], 'h': ['f', 'g', 'k'],
    't': ['d', 'p'], 'r': ['l', 'zh'],
    // Finals
    'a': ['ai', 'ao', 'e'],
    'e': ['ei', 'ie', 'a'],
    'i': ['ui', 'iu', 'ü'],
    'u': ['ü', 'ou'], 'ü': ['u', 'i'],
    'ai': ['ei', 'ao', 'an'], 'ei': ['ai', 'en', 'ie'],
    'ao': ['ou', 'ai'], 'ou': ['uo', 'ao', 'u'],
    'an': ['ang', 'en', 'uan'], 'en': ['eng', 'an', 'in'],
    'ang': ['an', 'eng', 'ong'], 'eng': ['en', 'ing', 'ang'],
    'in': ['ing', 'en'], 'ing': ['in', 'eng'],
    'ong': ['eng', 'ang', 'iong'],
    'uo': ['ou', 'ua'], 'ua': ['uo', 'uai'],
    'ie': ['ei', 'e'], 'iu': ['ui', 'i'],
    'uan': ['an', 'uang'], 'uang': ['uan', 'ang'],
    'iong': ['ong', 'ing']
  };
  
  // Deterministic seeded random generator (same as front)
  let seed = 0;
  const seedString = correctAnswer;
  for (let i = 0; i < seedString.length; i++) {
    seed = (seed + seedString.charCodeAt(i)) % 100000;
  }
  const seededRandom = function() {
    var x = Math.sin(seed++) * 10000;
    return x - Math.floor(x);
  };
  
  // Fisher-Yates shuffle with seeded random
  function shuffleArray(array) {
    const shuffled = array.slice();
    for (let i = shuffled.length - 1; i > 0; i--) {
      const j = Math.floor(seededRandom() * (i + 1));
      [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
    }
    return shuffled;
  }
  
  // Normalization Helper: Strip tones from syllable (same as front)
  function stripTone(syllable) {
    if (!syllable) return '';
    const normalized = syllable.normalize('NFD');
    const stripped = normalized.replace(/[\u0300-\u036f]/g, '');
    return stripped.toLowerCase();
  }
  
  // Parse syllable into initial and final (same as front)
  function parseSyllable(syllable) {
    const noTone = stripTone(syllable);
    const initials = ['zh', 'ch', 'sh', 'b', 'p', 'm', 'f', 'd', 't', 'n', 'l', 
                      'g', 'k', 'h', 'j', 'q', 'x', 'z', 'c', 's', 'r', 'y', 'w'];
    
    let initial = '';
    let final = noTone;
    
    for (const init of initials) {
      if (noTone.startsWith(init)) {
        initial = init;
        final = noTone.substring(init.length);
        break;
      }
    }
    
    return { initial: initial, final: final, original: syllable };
  }
  
  // Extract tone from syllable (same as front)
  function extractTone(syllable) {
    if (!syllable) return null;
    const normalized = syllable.normalize('NFD');
    const toneMap = {
      '\u0304': 1, '\u0301': 2, '\u030C': 3, '\u0300': 4
    };
    
    for (let i = 0; i < normalized.length; i++) {
      const char = normalized[i];
      if (toneMap[char]) {
        return toneMap[char];
      }
    }
    return null;
  }
  
  // Add tone to syllable (same as front)
  function addTone(syllable, tone) {
    if (!tone || !syllable) return syllable;
    
    const toneMarks = {
      1: { 'a': 'ā', 'e': 'ē', 'i': 'ī', 'o': 'ō', 'u': 'ū', 'ü': 'ǖ' },
      2: { 'a': 'á', 'e': 'é', 'i': 'í', 'o': 'ó', 'u': 'ú', 'ü': 'ǘ' },
      3: { 'a': 'ǎ', 'e': 'ě', 'i': 'ǐ', 'o': 'ǒ', 'u': 'ǔ', 'ü': 'ǚ' },
      4: { 'a': 'à', 'e': 'è', 'i': 'ì', 'o': 'ò', 'u': 'ù', 'ü': 'ǜ' }
    };
    
    const marks = toneMarks[tone];
    if (!marks) return syllable;
    
    const vowels = ['a', 'e', 'i', 'o', 'u', 'ü'];
    for (let i = 0; i < syllable.length; i++) {
      const char = syllable[i].toLowerCase();
      if (vowels.includes(char) && marks[char]) {
        return syllable.substring(0, i) + marks[char] + syllable.substring(i + 1);
      }
    }
    
    return syllable;
  }
  
  // Generate phonetic confusors (same as front)
  function generatePhoneticConfusors(correctSyllable, db, count) {
    const parsed = parseSyllable(correctSyllable);
    const tone = extractTone(correctSyllable);
    const confusors = [];
    const seen = new Set([correctSyllable]);
    
    const initialConfusors = CONFUSION_GROUPS[parsed.initial] || [];
    const finalConfusors = CONFUSION_GROUPS[parsed.final] || [];
    
    let swapInitial = true;
    let initialIndex = 0;
    let finalIndex = 0;
    
    while (confusors.length < count && (initialIndex < initialConfusors.length || finalIndex < finalConfusors.length)) {
      let newSyllable = '';
      
      if (swapInitial && initialIndex < initialConfusors.length) {
        const newInitial = initialConfusors[initialIndex];
        newSyllable = newInitial + parsed.final;
        initialIndex++;
      } else if (finalIndex < finalConfusors.length) {
        const newFinal = finalConfusors[finalIndex];
        newSyllable = parsed.initial + newFinal;
        finalIndex++;
      } else {
        break;
      }
      
      if (tone) {
        newSyllable = addTone(newSyllable, tone);
      }
      
      if (!seen.has(newSyllable)) {
        const existsInDb = db.some(item => {
          const itemNoTone = stripTone(item.syllable);
          const newNoTone = stripTone(newSyllable);
          return itemNoTone === newNoTone;
        });
        
        if (existsInDb) {
          const dbItem = db.find(item => {
            const itemNoTone = stripTone(item.syllable);
            const newNoTone = stripTone(newSyllable);
            return itemNoTone === newNoTone;
          });
          if (dbItem && !seen.has(dbItem.syllable)) {
            confusors.push(dbItem.syllable);
            seen.add(dbItem.syllable);
          }
        }
      }
      
      swapInitial = !swapInitial;
    }
    
    if (confusors.length < count) {
      const available = db
        .map(item => item.syllable)
        .filter(s => s && !seen.has(s));
      
      const unique = [...new Set(available)];
      const needed = count - confusors.length;
      
      for (let i = 0; i < needed && unique.length > 0; i++) {
        const index = Math.floor(seededRandom() * unique.length);
        confusors.push(unique[index]);
        seen.add(unique[index]);
        unique.splice(index, 1);
      }
    }
    
    return confusors.slice(0, count);
  }
  
  // Function to ensure options are generated and in correct order
  function ensureOptionsGenerated() {
    // Check if options already exist (from front side)
    const existingOptions = container.querySelectorAll('.mcq-option');
    
    if (existingOptions.length === 0) {
      // Options weren't generated on front side, generate them now
      if (typeof window === 'undefined' || !window.PINYIN_DB || !Array.isArray(window.PINYIN_DB)) {
        return; // Can't generate without DB
      }
      
      const db = window.PINYIN_DB;
      const distractors = generatePhoneticConfusors(correctAnswer, db, 3);
      
      // Create option objects
      const options = [
        { syllable: correctAnswer, isCorrect: true },
        ...distractors.map(syllable => ({
          syllable: syllable,
          isCorrect: false
        }))
      ];
      
      // Create button elements
      const buttons = options.map(option => {
        const btn = document.createElement('button');
        btn.className = 'mcq-option';
        btn.setAttribute('data-value', option.syllable);
        btn.setAttribute('data-correct', option.isCorrect ? 'true' : 'false');
        btn.textContent = option.syllable;
        return btn;
      });
      
      container.innerHTML = '';
      const shuffled = shuffleArray(buttons);
      shuffled.forEach(btn => container.appendChild(btn));
    }
    // If options already exist, preserve their order (they were already shuffled by front side)
    
    // Re-query after potential generation
    const finalOptions = container.querySelectorAll('.mcq-option');
    
    // Disable all buttons
    finalOptions.forEach(btn => {
      btn.disabled = true;
      btn.style.pointerEvents = 'none';
      
      // Remove all event listeners by cloning
      const newBtn = btn.cloneNode(true);
      btn.parentNode.replaceChild(newBtn, btn);
    });
    
    // Highlight correct answer
    const newOptions = container.querySelectorAll('.mcq-option');
    newOptions.forEach(btn => {
      if (btn.getAttribute('data-value') === correctAnswer) {
        btn.classList.add('selected');
      }
    });
  }
  
  // Try to ensure options are generated
  let attempts = 0;
  const maxAttempts = 40; // 40 * 50ms = 2 seconds
  
  function tryEnsure() {
    attempts++;
    
    if (typeof window !== 'undefined' && window.PINYIN_DB && Array.isArray(window.PINYIN_DB)) {
      ensureOptionsGenerated();
      return;
    }
    
    if (attempts >= maxAttempts) {
      return; // Give up after 2 seconds
    }
    
    setTimeout(tryEnsure, 50);
  }
  
  // Start trying to ensure options are generated
  tryEnsure();
})();
</script>
